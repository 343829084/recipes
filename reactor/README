Engineering a Reactor
 -- how to write a non-blocking network library from scratch.

Step 0: a do-nothing event loop
  EventLoop, assertInLoopThread()
  test1: poll for 10 seconds, creates two threads, each one has an EventLoop
  test2: abort() as it accesses event loop created in a different thread

Step 1: prototype of reactor
  Channel, Poller, updateChannel().
  test1: poll for ever, creates two threads, each one has an EventLoop
  test2: same as before
  test3: poll a timerfd, which expires in 5 seconds

Step 2: TimerQueue
  TimerQueue, Timer, TimerId, EventLoop::runAfter, EventLoop::runEvery
  not thread safe
  test4: timer queue unittest

Step 3: wakeup(), runInLoop()
  test5: runInLoop(), runAfter() in loop thread
  test6: runInLoop(), runAfter() in a different thread

Step 4: Acceptor
  test7: listen on port 9981, accept, send, and close

Step 5: TcpServer
  test8: use of TcpServer

Step 7: TcpConnection read

Step 6: TcpConnection up and down

Step 8: TcpConnection write, write complete callback

Step 9: multithreaded TcpServer

Step 10: Connector

Step 11: TcpClient

Step 12: epoll

